/*
Facturapi

<br /> <br />  En esta página enlistamos todos los métodos disponibles en la API de Facturapi, así como la referencia completa de los parámetros que acepta cada uno. Para ver las propiedades anidadas de un objeto o arreglo de objetos, puedes hacer clic sobre el nombre del campo y expandirlo.  La API de Facturapi está diseñada con el estándar [REST](https://developer.mozilla.org/en-US/docs/Glossary/REST) en mente. Los endpoints de la API están agrupados por recursos, tienen URLs predecibles, las respuestas tienen formato JSON y usamos códigos HTTP de respuesta, autenticación y verbos estándar.  Durante el desarrollo, puedes usar la API de Facturapi en ambiente Test y las facturas que emitas no se enviarán al SAT ni tendrán validez fiscal.  La llave secreta que utilices para autenticarte determinará tanto el ambiente en el que se creará la factura (Test o Live), así como la organización a utilizar como emisor de tu factura, o bien como dueña del recurso que solicites crear. 

API version: 2.0
Contact: soporte@facturapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package facturapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// ReceiptAPIService ReceiptAPI service
type ReceiptAPIService service

type ApiCancelReceiptRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptId string
}

func (r ApiCancelReceiptRequest) Execute() (*Receipt, *http.Response, error) {
	return r.ApiService.CancelReceiptExecute(r)
}

/*
CancelReceipt Cancelar recibo

Marca un recibo como cancelado, cambiando su propiedad `status` a `"canceled"`.

Una vez cancelado, el recibo no podrá ser facturado.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId ID del recibo a cancelar
 @return ApiCancelReceiptRequest
*/
func (a *ReceiptAPIService) CancelReceipt(ctx context.Context, receiptId string) ApiCancelReceiptRequest {
	return ApiCancelReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
	}
}

// Execute executes the request
//  @return Receipt
func (a *ReceiptAPIService) CancelReceiptExecute(r ApiCancelReceiptRequest) (*Receipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.CancelReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/{receipt_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateGlobalInvoiceRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	globalInvoiceInput *GlobalInvoiceInput
}

func (r ApiCreateGlobalInvoiceRequest) GlobalInvoiceInput(globalInvoiceInput GlobalInvoiceInput) ApiCreateGlobalInvoiceRequest {
	r.globalInvoiceInput = &globalInvoiceInput
	return r
}

func (r ApiCreateGlobalInvoiceRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.CreateGlobalInvoiceExecute(r)
}

/*
CreateGlobalInvoice Crear factura global

Crea una factura global que incluirá todos los recibos con `status = “open”` de un cierto periodo.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateGlobalInvoiceRequest
*/
func (a *ReceiptAPIService) CreateGlobalInvoice(ctx context.Context) ApiCreateGlobalInvoiceRequest {
	return ApiCreateGlobalInvoiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoice
func (a *ReceiptAPIService) CreateGlobalInvoiceExecute(r ApiCreateGlobalInvoiceRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.CreateGlobalInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/global-invoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.globalInvoiceInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateReceiptRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptInput *ReceiptInput
}

func (r ApiCreateReceiptRequest) ReceiptInput(receiptInput ReceiptInput) ApiCreateReceiptRequest {
	r.receiptInput = &receiptInput
	return r
}

func (r ApiCreateReceiptRequest) Execute() (*Receipt, *http.Response, error) {
	return r.ApiService.CreateReceiptExecute(r)
}

/*
CreateReceipt Crear recibo

Crea un nuevo Recibo, el cual funge como nota de venta.

Todos los recibos generan una URL de autofactura que cliente puede
visitar para llenar sus datos fiscales en un micrositio con el branding
de la organización.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateReceiptRequest
*/
func (a *ReceiptAPIService) CreateReceipt(ctx context.Context) ApiCreateReceiptRequest {
	return ApiCreateReceiptRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Receipt
func (a *ReceiptAPIService) CreateReceiptExecute(r ApiCreateReceiptRequest) (*Receipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.CreateReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.receiptInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadReceiptPdfRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptId string
}

func (r ApiDownloadReceiptPdfRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadReceiptPdfExecute(r)
}

/*
DownloadReceiptPdf Descargar PDF

Descarga el recibo digital en formato PDF.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId ID del objeto a descargar
 @return ApiDownloadReceiptPdfRequest
*/
func (a *ReceiptAPIService) DownloadReceiptPdf(ctx context.Context, receiptId string) ApiDownloadReceiptPdfRequest {
	return ApiDownloadReceiptPdfRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ReceiptAPIService) DownloadReceiptPdfExecute(r ApiDownloadReceiptPdfRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.DownloadReceiptPdf")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/{receipt_id}/pdf"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReceiptRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptId string
}

func (r ApiGetReceiptRequest) Execute() (*Receipt, *http.Response, error) {
	return r.ApiService.GetReceiptExecute(r)
}

/*
GetReceipt Obtener recibo por ID

Regresa el objeto 'Receipt' relacionado al `id` especificado.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId ID del objeto a obtener
 @return ApiGetReceiptRequest
*/
func (a *ReceiptAPIService) GetReceipt(ctx context.Context, receiptId string) ApiGetReceiptRequest {
	return ApiGetReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
	}
}

// Execute executes the request
//  @return Receipt
func (a *ReceiptAPIService) GetReceiptExecute(r ApiGetReceiptRequest) (*Receipt, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Receipt
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.GetReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/{receipt_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInvoiceReceiptRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptId string
	invoiceReceiptInput *InvoiceReceiptInput
}

func (r ApiInvoiceReceiptRequest) InvoiceReceiptInput(invoiceReceiptInput InvoiceReceiptInput) ApiInvoiceReceiptRequest {
	r.invoiceReceiptInput = &invoiceReceiptInput
	return r
}

func (r ApiInvoiceReceiptRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.InvoiceReceiptExecute(r)
}

/*
InvoiceReceipt Facturar recibo

Crea una factura a partir de un recibo.

Sólo pueden facturarse recibos abiertos (`status = "open"`)

Una vez facturado, el `status` del recibo cambiará a `"invoiced_to_customer"`.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId ID del objeto a obtener
 @return ApiInvoiceReceiptRequest
*/
func (a *ReceiptAPIService) InvoiceReceipt(ctx context.Context, receiptId string) ApiInvoiceReceiptRequest {
	return ApiInvoiceReceiptRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
	}
}

// Execute executes the request
//  @return Invoice
func (a *ReceiptAPIService) InvoiceReceiptExecute(r ApiInvoiceReceiptRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.InvoiceReceipt")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/{receipt_id}/invoice"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.invoiceReceiptInput
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListReceiptsRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	q *string
	paymentForm *string
	date *DateRange
	page *interface{}
	limit *interface{}
}

// Consulta. Texto a buscar en la descripción de los conceptos del recibo o el SKU. 
func (r ApiListReceiptsRequest) Q(q string) ApiListReceiptsRequest {
	r.q = &q
	return r
}

// Código que representa la forma de pago, de acuerdo al [catálogo del SAT](#forma-de-pago). Si se incluye, los recibos se agruparán y se listarán de acuerdo a la forma de pago. 
func (r ApiListReceiptsRequest) PaymentForm(paymentForm string) ApiListReceiptsRequest {
	r.paymentForm = &paymentForm
	return r
}

// Objeto con rango de fechas solicitado.
func (r ApiListReceiptsRequest) Date(date DateRange) ApiListReceiptsRequest {
	r.date = &date
	return r
}

// Página de resultados a regresar, empezando desde la página 1.
func (r ApiListReceiptsRequest) Page(page interface{}) ApiListReceiptsRequest {
	r.page = &page
	return r
}

// Número del 1 al 100 que representa la cantidad máxima de resultados a regresar con motivos de paginación.
func (r ApiListReceiptsRequest) Limit(limit interface{}) ApiListReceiptsRequest {
	r.limit = &limit
	return r
}

func (r ApiListReceiptsRequest) Execute() (*ReceiptSearchResult, *http.Response, error) {
	return r.ApiService.ListReceiptsExecute(r)
}

/*
ListReceipts Listar recibos

Regresa una lista paginada de todos los recibos de una organización o realiza una búsqueda de acuerdo a parámetros

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListReceiptsRequest
*/
func (a *ReceiptAPIService) ListReceipts(ctx context.Context) ApiListReceiptsRequest {
	return ApiListReceiptsRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ReceiptSearchResult
func (a *ReceiptAPIService) ListReceiptsExecute(r ApiListReceiptsRequest) (*ReceiptSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReceiptSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.ListReceipts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.paymentForm != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payment_form", r.paymentForm, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue interface{} = 50
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendReceiptByEmailRequest struct {
	ctx context.Context
	ApiService *ReceiptAPIService
	receiptId string
	sendReceiptByEmailRequest *SendReceiptByEmailRequest
}

func (r ApiSendReceiptByEmailRequest) SendReceiptByEmailRequest(sendReceiptByEmailRequest SendReceiptByEmailRequest) ApiSendReceiptByEmailRequest {
	r.sendReceiptByEmailRequest = &sendReceiptByEmailRequest
	return r
}

func (r ApiSendReceiptByEmailRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.SendReceiptByEmailExecute(r)
}

/*
SendReceiptByEmail Enviar recibo por correo electrónico

Envía un correo electrónico a la dirección de tu cliente.

El correo enviado estará personalizado con el logotipo y los colores de la organización que lo creó,
e incluirá un botón para facturar el recibo, así con el recibo en formato PDF adjunto al mensaje.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param receiptId ID del objeto a obtener
 @return ApiSendReceiptByEmailRequest
*/
func (a *ReceiptAPIService) SendReceiptByEmail(ctx context.Context, receiptId string) ApiSendReceiptByEmailRequest {
	return ApiSendReceiptByEmailRequest{
		ApiService: a,
		ctx: ctx,
		receiptId: receiptId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *ReceiptAPIService) SendReceiptByEmailExecute(r ApiSendReceiptByEmailRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ReceiptAPIService.SendReceiptByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/receipts/{receipt_id}/email"
	localVarPath = strings.Replace(localVarPath, "{"+"receipt_id"+"}", url.PathEscape(parameterValueToString(r.receiptId, "receiptId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendReceiptByEmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
