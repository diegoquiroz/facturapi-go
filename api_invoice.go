/*
Facturapi

<br /> <br />  En esta página enlistamos todos los métodos disponibles en la API de Facturapi, así como la referencia completa de los parámetros que acepta cada uno. Para ver las propiedades anidadas de un objeto o arreglo de objetos, puedes hacer clic sobre el nombre del campo y expandirlo.  La API de Facturapi está diseñada con el estándar [REST](https://developer.mozilla.org/en-US/docs/Glossary/REST) en mente. Los endpoints de la API están agrupados por recursos, tienen URLs predecibles, las respuestas tienen formato JSON y usamos códigos HTTP de respuesta, autenticación y verbos estándar.  Durante el desarrollo, puedes usar la API de Facturapi en ambiente Test y las facturas que emitas no se enviarán al SAT ni tendrán validez fiscal.  La llave secreta que utilices para autenticarte determinará tanto el ambiente en el que se creará la factura (Test o Live), así como la organización a utilizar como emisor de tu factura, o bien como dueña del recurso que solicites crear. 

API version: 2.0
Contact: soporte@facturapi.io
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package facturapi-go

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


// InvoiceAPIService InvoiceAPI service
type InvoiceAPIService service

type ApiCancelInvoiceRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	invoiceId string
	motive *string
	substitution *string
}

// Clave que representa el motivo de la cancelación de la factura.  - &#x60;01&#x60;: **Comprobante emitido con errores con relación**. Cuando la   factura contiene algún error en las cantidades, claves o cualquier otro dato y ya   se ha emitido el comprobante que la sustituye, el cual deberá indicarse por medio   del atributo &#x60;substitution&#x60;. - &#x60;02&#x60;: **Comprobante emitido con errores sin relación**. Cuando la   factura contiene algún error en las cantidades, claves o cualquier otro dato y no   se requiere relacionar con otra factura. - &#x60;03&#x60;: **No se llevó a cabo la operación**. Cuando la venta o transacción no se concretó. - &#x60;04&#x60;: **Operación nominativa relacionada en la factura global**. Cuando se requiere cancelar   una factura al público en general porque el cliente solicita su comprobante. 
func (r ApiCancelInvoiceRequest) Motive(motive string) ApiCancelInvoiceRequest {
	r.motive = &motive
	return r
}

// ID de la factura que sustituye a la factura que se está cancelando.  Puedes usar el ID de Facturapi o el folio fiscal (UUID). 
func (r ApiCancelInvoiceRequest) Substitution(substitution string) ApiCancelInvoiceRequest {
	r.substitution = &substitution
	return r
}

func (r ApiCancelInvoiceRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.CancelInvoiceExecute(r)
}

/*
CancelInvoice Cancelar factura

Realiza una solicitud de cancelación de factura ante el SAT, soportando el esquema de cancelación 2022.

Al usar este método pueden ocurrir 3 posibles resultados:

- Que la llamada regrese un error con la explicación de por qué no se pudo cancelar.
- Que la llamada sea satisfactoria y regrese un objeto `invoice` con la propiedad `status: "canceled"`.
- Que la llamada sea satisfactoria, pero que la cancelación requiera de confirmación de parte de tu cliente, en cuyo caso se obtendrá como respuesta el objeto `invoice` con las propiedades `status: "valid"` y `cancellation_status: "pending"`.

En el tercer escenario, el valor de `cancellation_status` será actualizado automáticamente por Facturapi cuando tu cliente acepte, rechace o deje expirar la solicitud, de tal manera que al consultar una factura (usando [Obtener Factura](#operation/getInvoice)), la propiedad `cancellation_status` reflejará el estado más reciente de la soliitud.

Consulta los valores posibles de `cancellation_status` más abajo.

Después de la cancelación la factura ya no tendrá validez, el objeto cambiará su `status` a `"canceled"` y seguirá estando disponible para futuras consultas.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId ID de la factura a cancelar
 @return ApiCancelInvoiceRequest
*/
func (a *InvoiceAPIService) CancelInvoice(ctx context.Context, invoiceId string) ApiCancelInvoiceRequest {
	return ApiCancelInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Invoice
func (a *InvoiceAPIService) CancelInvoiceExecute(r ApiCancelInvoiceRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.CancelInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/{invoice_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoice_id"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.motive == nil {
		return localVarReturnValue, nil, reportError("motive is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "motive", r.motive, "")
	if r.substitution != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "substitution", r.substitution, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateInvoiceRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	createInvoiceRequest *CreateInvoiceRequest
}

func (r ApiCreateInvoiceRequest) CreateInvoiceRequest(createInvoiceRequest CreateInvoiceRequest) ApiCreateInvoiceRequest {
	r.createInvoiceRequest = &createInvoiceRequest
	return r
}

func (r ApiCreateInvoiceRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.CreateInvoiceExecute(r)
}

/*
CreateInvoice Crear factura (CFDI 4.0)

Crea una nueva Factura. Si la factura es creada en ambiente Live, ésta será **timbrada y enviada al SAT**.


 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateInvoiceRequest
*/
func (a *InvoiceAPIService) CreateInvoice(ctx context.Context) ApiCreateInvoiceRequest {
	return ApiCreateInvoiceRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Invoice
func (a *InvoiceAPIService) CreateInvoiceExecute(r ApiCreateInvoiceRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.CreateInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createInvoiceRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadCancellationReceiptXmlRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	invoiceId string
}

func (r ApiDownloadCancellationReceiptXmlRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadCancellationReceiptXmlExecute(r)
}

/*
DownloadCancellationReceiptXml Descargar acuse de cancelación

Descarga acuse de recibo de cancelación de una factura en un archivo xml.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId ID del objeto a obtener
 @return ApiDownloadCancellationReceiptXmlRequest
*/
func (a *InvoiceAPIService) DownloadCancellationReceiptXml(ctx context.Context, invoiceId string) ApiDownloadCancellationReceiptXmlRequest {
	return ApiDownloadCancellationReceiptXmlRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *InvoiceAPIService) DownloadCancellationReceiptXmlExecute(r ApiDownloadCancellationReceiptXmlRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.DownloadCancellationReceiptXml")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/{invoice_id}/cancellation_receipt/xml"
	localVarPath = strings.Replace(localVarPath, "{"+"invoice_id"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDownloadInvoiceRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	invoiceId string
	format string
}

func (r ApiDownloadInvoiceRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.DownloadInvoiceExecute(r)
}

/*
DownloadInvoice Descargar factura

Descarga tu Factura en PDF, XML o ambos en un archivo comprimido ZIP.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId ID del objeto a descargar
 @param format Formato del archivo de descarga
 @return ApiDownloadInvoiceRequest
*/
func (a *InvoiceAPIService) DownloadInvoice(ctx context.Context, invoiceId string, format string) ApiDownloadInvoiceRequest {
	return ApiDownloadInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
		format: format,
	}
}

// Execute executes the request
//  @return *os.File
func (a *InvoiceAPIService) DownloadInvoiceExecute(r ApiDownloadInvoiceRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.DownloadInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/{invoice_id}/{format}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoice_id"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"format"+"}", url.PathEscape(parameterValueToString(r.format, "format")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetInvoiceRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	invoiceId string
}

func (r ApiGetInvoiceRequest) Execute() (*Invoice, *http.Response, error) {
	return r.ApiService.GetInvoiceExecute(r)
}

/*
GetInvoice Obtener factura por ID

Regresa el objeto 'Invoice' relacionado al `id` especificado.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId ID del objeto a obtener
 @return ApiGetInvoiceRequest
*/
func (a *InvoiceAPIService) GetInvoice(ctx context.Context, invoiceId string) ApiGetInvoiceRequest {
	return ApiGetInvoiceRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return Invoice
func (a *InvoiceAPIService) GetInvoiceExecute(r ApiGetInvoiceRequest) (*Invoice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Invoice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.GetInvoice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/{invoice_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"invoice_id"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListInvoicesRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	q *string
	customer *string
	type_ *string
	paymentMethod *string
	date *DateRange
	page *interface{}
	limit *interface{}
}

// Consulta. Texto a buscar en la factura.  La búsqueda se realizará por coincidencias **parciales** en los campos:  - &#x60;items[].product.description&#x60; - &#x60;customer.legal_name&#x60;  Y por coincidencias **exactas** en los campos:  - &#x60;id&#x60; - &#x60;uuid&#x60; - &#x60;customer.tax_id&#x60; - &#x60;folio_number&#x60; - &#x60;total&#x60; 
func (r ApiListInvoicesRequest) Q(q string) ApiListInvoicesRequest {
	r.q = &q
	return r
}

// Identificador del cliente. Útil para obtener las facturas emitidas a un sólo cliente.
func (r ApiListInvoicesRequest) Customer(customer string) ApiListInvoicesRequest {
	r.customer = &customer
	return r
}

// Tipo de factura. Búsqueda por tipo de factura con las claves exactas.
func (r ApiListInvoicesRequest) Type_(type_ string) ApiListInvoicesRequest {
	r.type_ = &type_
	return r
}

// Método de pago. Búsqueda exacta por método de pago.
func (r ApiListInvoicesRequest) PaymentMethod(paymentMethod string) ApiListInvoicesRequest {
	r.paymentMethod = &paymentMethod
	return r
}

// Objeto con rango de fechas solicitado.
func (r ApiListInvoicesRequest) Date(date DateRange) ApiListInvoicesRequest {
	r.date = &date
	return r
}

// Página de resultados a regresar, empezando desde la página 1.
func (r ApiListInvoicesRequest) Page(page interface{}) ApiListInvoicesRequest {
	r.page = &page
	return r
}

// Número del 1 al 100 que representa la cantidad máxima de resultados a regresar con motivos de paginación.
func (r ApiListInvoicesRequest) Limit(limit interface{}) ApiListInvoicesRequest {
	r.limit = &limit
	return r
}

func (r ApiListInvoicesRequest) Execute() (*InvoiceSearchResult, *http.Response, error) {
	return r.ApiService.ListInvoicesExecute(r)
}

/*
ListInvoices Listar facturas

Regresa una lista paginada de todas las facturas de una organización o realiza una búsqueda de acuerdo a parámetros

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListInvoicesRequest
*/
func (a *InvoiceAPIService) ListInvoices(ctx context.Context) ApiListInvoicesRequest {
	return ApiListInvoicesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return InvoiceSearchResult
func (a *InvoiceAPIService) ListInvoicesExecute(r ApiListInvoicesRequest) (*InvoiceSearchResult, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *InvoiceSearchResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.ListInvoices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.q != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "q", r.q, "")
	}
	if r.customer != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "customer", r.customer, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.paymentMethod != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "payment_method", r.paymentMethod, "")
	}
	if r.date != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "date", r.date, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue interface{} = 50
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendInvoiceByEmailRequest struct {
	ctx context.Context
	ApiService *InvoiceAPIService
	invoiceId string
	sendInvoiceByEmailRequest *SendInvoiceByEmailRequest
}

func (r ApiSendInvoiceByEmailRequest) SendInvoiceByEmailRequest(sendInvoiceByEmailRequest SendInvoiceByEmailRequest) ApiSendInvoiceByEmailRequest {
	r.sendInvoiceByEmailRequest = &sendInvoiceByEmailRequest
	return r
}

func (r ApiSendInvoiceByEmailRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.SendInvoiceByEmailExecute(r)
}

/*
SendInvoiceByEmail Enviar factura por correo electrónico

Envía un correo electrónico a la dirección de tu cliente, con los archivos XML y PDF adjuntos al mensaje.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param invoiceId ID del objeto a obtener
 @return ApiSendInvoiceByEmailRequest
*/
func (a *InvoiceAPIService) SendInvoiceByEmail(ctx context.Context, invoiceId string) ApiSendInvoiceByEmailRequest {
	return ApiSendInvoiceByEmailRequest{
		ApiService: a,
		ctx: ctx,
		invoiceId: invoiceId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *InvoiceAPIService) SendInvoiceByEmailExecute(r ApiSendInvoiceByEmailRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InvoiceAPIService.SendInvoiceByEmail")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/invoices/{invoice_id}/email"
	localVarPath = strings.Replace(localVarPath, "{"+"invoice_id"+"}", url.PathEscape(parameterValueToString(r.invoiceId, "invoiceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/octet-stream", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sendInvoiceByEmailRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
